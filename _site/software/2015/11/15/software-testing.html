

<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7 ie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8 ie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9 ie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="tr"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Software Testing</title>
	<meta name="author" content="Barış Aydek">

	<!-- for Google -->
	<meta name="description" content="Bu yazıda testing'in önemi, yanlış bilinenler, test çeşitleri hakkında okuyabilirsiniz." />
	<meta name="keywords" content="" />

	<meta name="author" content="Barış Aydek" />
	<meta name="copyright" content="" />
	<meta name="application-name" content="Dhalsim's" />

	<!-- for Facebook -->
	<meta property="og:title" content="Software Testing" />
	<meta property="og:type" content="article" />
	<meta property="og:image" content="http://dhalsim.github.io/assets/images/happygoat.jpg" />
	<meta property="og:url" content="http://dhalsim.github.io/software/2015/11/15/software-testing" />
	<meta property="og:description" content="Bu yazıda testing'in önemi, yanlış bilinenler, test çeşitleri hakkında okuyabilirsiniz." />

	<!-- for Twitter -->
	<meta name="twitter:card" content="summary_large_image" />
	<meta name="twitter:title" content="Software Testing" />
	<meta name="twitter:description" content="Bu yazıda testing'in önemi, yanlış bilinenler, test çeşitleri hakkında okuyabilirsiniz." />
	<meta name="twitter:image" content="http://dhalsim.github.io/assets/images/happygoat.jpg" />
	<meta name="twitter:creator" content="@mustapha_alaziz">

  <style>
	  @font-face {
			font-family: 'Allerta';
			src: url('/assets/fonts/Allerta-Regular.eot'); /* IE9 Compat Modes */
			src: url('/assets/fonts/Allerta-Regular.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
					 url('/assets/fonts/Allerta-Regular.woff2') format('woff2'), /* Super Modern Browsers */
					 url('/assets/fonts/Allerta-Regular.woff') format('woff'), /* Pretty Modern Browsers */
					 url('/assets/fonts/Allerta-Regular.ttf')  format('truetype'), /* Safari, Android, iOS */
					 url('/assets/fonts/Allerta-Regular.svg#svgFontName') format('svg'); /* Legacy iOS */
		}
		@font-face {
			font-family: 'Punk';
			src: url('/assets/fonts/punk-regular.eot'); /* IE9 Compat Modes */
			src: url('/assets/fonts/punk-regular.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
					 url('/assets/fonts/punk-regular.woff2') format('woff2'), /* Super Modern Browsers */
					 url('/assets/fonts/punk-regularwoff') format('woff'), /* Pretty Modern Browsers */
					 url('/assets/fonts/punk-regular.ttf')  format('truetype'), /* Safari, Android, iOS */
					 url('/assets/fonts/punk-regular.svg#svgFontName') format('svg'); /* Legacy iOS */
		}

		@font-face {
			font-family: 'Ewert';
			src: url('/assets/fonts/Ewert-Regular.eot'); /* IE9 Compat Modes */
			src: url('/assets/fonts/Ewert-Regular.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
					 url('/assets/fonts/Ewert-Regular.woff2') format('woff2'), /* Super Modern Browsers */
					 url('/assets/fonts/Ewert-Regularwoff') format('woff'), /* Pretty Modern Browsers */
					 url('/assets/fonts/Ewert-Regular.ttf')  format('truetype'), /* Safari, Android, iOS */
					 url('/assets/fonts/Ewert-Regular.svg#svgFontName') format('svg'); /* Legacy iOS */
		}
	</style>
	<link href='/assets/themes/the-program/css/style.css' rel="stylesheet" media="all">
	<link href='/assets/css/mystyles.css' rel="stylesheet" media="all">
	<link href='/assets/css/flags/flags.css' rel="stylesheet" media="all">
	<link href="http://feeds.feedburner.com/" rel="alternate" title="Software Testing" type="application/atom+xml">
	<style media="screen">
	.cd-top {
	  display: inline-block;
	  height: 40px;
	  width: 40px;
	  position: fixed;
	  bottom: 100px;
	  right: 10px;
	  z-index: 10;
	  box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
	  /* image replacement properties */
	  overflow: hidden;
	  text-indent: 100%;
	  white-space: nowrap;
	  background: rgba(232, 98, 86, 0.8) url(/assets/images/cd-top-arrow.svg) no-repeat center 50%;
	  visibility: hidden;
	  opacity: 0;
	  -webkit-transition: opacity .3s 0s, visibility 0s .3s;
	  -moz-transition: opacity .3s 0s, visibility 0s .3s;
	  transition: opacity .3s 0s, visibility 0s .3s;
	}
	.cd-top.cd-is-visible, .cd-top.cd-fade-out, .no-touch .cd-top:hover {
	  -webkit-transition: opacity .3s 0s, visibility 0s 0s;
	  -moz-transition: opacity .3s 0s, visibility 0s 0s;
	  transition: opacity .3s 0s, visibility 0s 0s;
	}
	.cd-top.cd-is-visible {
	  /* the button becomes visible */
	  visibility: visible;
	  opacity: 1;
	}
	.cd-top.cd-fade-out {
	  /* if the user keeps scrolling down, the button is out of focus and becomes less visible */
	  opacity: .5;
	}
	.no-touch .cd-top:hover {
	  background-color: #e86256;
	  opacity: 1;
	}
	@media only screen and (min-width: 768px) {
	  .cd-top {
	    right: 20px;
	    bottom: 20px;
	  }
	}
	@media only screen and (min-width: 1024px) {
	  .cd-top {
	    height: 60px;
	    width: 60px;
	    right: 30px;
	    bottom: 30px;
	  }
	}
	</style>
	
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.css" charset="utf-8">
	
</head>
<body>
<a href="#0" class="cd-top cd-is-visible">Top</a>
<div id="page" class="hentry">
	<header class="the-header">
		<div class="unit-head">
			<div class="unit-inner unit-head-inner">
				<nav class="nav-global">
					<ul>
						<li class="logo" style="height: 249px;">
							<a href="">
								<img src="/assets/dhalsim_logo.gif" />
							</a>
						</li>
						<li class="logo">
							<a href="/">
								Dhalsim's
							</a>
						</li>
						<li class="archive"><a href="/archive.html">Arşiv</a></li>
						<li class="page"><a href="/pages.html">Sayfalar</a></li>
						<li class="category"><a href="/categories.html">Kategoriler</a></li>
						<li class="tag"><a href="/tags.html">Taglar</a></li>
					</ul>

					<hr />
					<nav class="languageSelector">
						
							<a href="/en" ><img src="/assets/blank.gif" class="flag flag-gb" alt="İngilizce" /> </a><a href="/en" class="alink">İngilizce</a>
						
						-
						
							<img src="/assets/blank.gif" class="flag flag-tr" alt="Türkçe" /> Türkçe
						
					</nav>
				</nav>
			</div><!-- unit-inner -->
		</div><!-- unit-head -->
	</header>
	<div class="body" role="main">
		<div class="unit-body">
			<div class="unit-inner unit-body-inner">
				<div class="entry-content">
					

<article class="unit-article layout-post">
	<div class="unit-inner unit-article-inner">
		<div class="content">
			<header>
				<div class="unit-head">
					<div class="unit-inner unit-head-inner">
						<h1 class="h2 entry-title">Software Testing</h1>
					</div><!-- unit-inner -->
				</div><!-- unit-head -->
				<div class="toc">
					<span>İçindekiler tablosu yükleniyor...</span>
					<div class="sp-circle"></div>
				</div>
			</header>

			<div class="bd">
				<div class="entry-content">
					<div class="seriesNote">
  Bu makale <strong>2</strong> bölümlük <strong>Teori Önemlidir!</strong> serisinin <strong>2.</strong> bölümüdür.</p>
    <ul>
    
    
    
    
    
    
    
    
    
    
    
    
    
        

    
    
        <li class="">Part 1 -
        
            <a href="/software/2015/11/14/software-development-processes">
        
    Yazılım Geliştirme Modelleri
    
      </a>
    
        </li>
    
    
    
    
    
    
    
        

    
    
        <li class="selected">Part 2 -
        
    Software Testing
    
        </li>
    
    
    
    
    </ul>
</div>

<h1>Tanım</h1>

<blockquote>
<p><strong>Yazılım testi:</strong> Yazılım ürününün <em>production</em>&#39;a geçmeden önce, yazılımın doğruluğunun ve kalitesinin kontrol edilmesi, varsa hataların bulunup tespit edilmesi işlemidir.</p>
</blockquote>

<p>Tanımı yaptık, hadi dağılın. Yok daha başlamadık bile. Önce doğru çalışan yazılımın neden önemli olduğunun sebeplerine bakalım. Aşağıda önemli yazılım hatalarının tarihte sebep olduğu olaylar listeleniyor:</p>

<h2>Yazılım kazaları</h2>

<p>Neredeyse 3. Dünya Savaşını başlatacak hatalar:</p>

<ul>
<li>1980, Amerika Hava Savunma Komutanlığı, iletişim cihazındaki hata bir nükleer saldırının yaşandığını yayıyor.</li>
<li>1983, Sovyet uydusu, Amerikan füzesi saldırısı raporu veriyor.</li>
</ul>

<p>Hastalıklar:</p>

<ul>
<li>1985-87 arası radyasyon tedavi aracındaki hata, en az 3 kişinin ölüme, çoğu hastanın da 100 kat fazla radyasyon almasına yol açıyor.</li>
</ul>

<p>Para kaybı:</p>

<ul>
<li>1996, uzaya uydu gönderilmesinde roket yazılımdaki hata yörüngede sapmaya neden olup roketin kendini patlatmasına neden oluyor. Hatanın maliyeti 370 milyon dolar.</li>
<li>1999, yine uydu fırlatmasındaki hata 1.2 milyar dolara maloluyor.</li>
<li>1996, banka yazılım hatası 832 müşterinin 920 milyon dolar borçlandırıyor.</li>
</ul>

<p>Kazalar:</p>

<ul>
<li>1994, sistem hatası bir helikopterin düşmesine ve 29 kişinin ölmesine neden oluyor.</li>
<li>1993, uçak sistemindeki bir hata şuna yol açıyor: <a href="https://www.youtube.com/watch?v=4iToQ2FykoI">https://www.youtube.com/watch?v=4iToQ2FykoI</a></li>
<li>1994, Çin&#39;de yazılım hatası uçak kazasına yol açıyor: 264 ölü.</li>
</ul>

<p>Vakit kayıpları:</p>

<ul>
<li>2015, Türkiye&#39;de herhangi bir devlet dairesindeki memur: Sistemler çalışmıyor!</li>
</ul>

<p>Yani neymiş işimiz kolay değilmiş, yapılan hatalar farkedilmeden <em>production</em>&#39;a çıkarıldığında en basitinden para ve zaman kaybına ve hatta ölüm ve yaralanmalara yol açabiliyormuş! Bu hataları azaltmanın en etkili yöntemlerinden biri de tabii ki yazılım testidir.</p>

<p>Yazılım test otomasyonu ise yazılımın test edilmesinde en güzel yöntemdir. Bu yöntemlere gelmeden önce, konu hakkındaki önyargıları yıkmak adına yanlış bilinenlerden devam edelim.</p>

<h2>Yanlış bilinenler</h2>

<ul>
<li><strong>Bilinen:</strong> Yazılımın testi, yazılım <em>production</em>&#39;a geçmeden hemen önce yapılmalıdır.</li>
<li><strong>Doğrusu:</strong> Yazılım testi yapılabildiği en erken zamanda yapılmaya başlanmalı, mümkünse her değişiklikte güncellenmeli ve tekrarlanmalıdır.</li>
<li><strong>Bilinen:</strong> Yazılım testi için stajerler kullanılmalı</li>
<li><strong>Doğrusu:</strong> Yazılım testi uzmanlık gerektiren bir konudur ve ayrı bir profesyonel ekip tarafından gerçekleştirilmelidir. Ancak o yazılımla alakalı her paydaşın (stakeholder) testte rol alması gerekir: Müşteri, developer, tester, analizci vs.</li>
<li><strong>Bilinen:</strong> Yazılım testi bittikten sonraki yapılan değişiklikler test edilmelidir.</li>
<li><strong>Doğrusu:</strong> Herhangibir değişiklik sonrası tüm test senaryoları tekrarlanmalıdır</li>
<li><strong>Bilinen:</strong> X tipi testing modeli en uygunudur.</li>
<li><strong>Doğrusu:</strong> Testing modeli, proje development modeline göre değişkenlik gösterir</li>
<li><strong>Bilinen:</strong> Tüm kodlama bittikten sonra testing başlar</li>
<li><strong>Doğrusu:</strong> Development modeline göre değişir, eğer <em>Agile</em> gibi metodolojilerde <em>testing</em>, gereksinim analiziyle başlar.</li>
<li><strong>Bilinen:</strong> Yazılım testi, yazılım iş gereksinimleriyle ilgilenir.</li>
<li><strong>Doğrusu:</strong> Sadece iş gereksinimleriyle değil, aynı zamanda görünürde olmayan performans ve güvenlik gereksinimlerine de bakılmalıdır.</li>
<li><strong>Bilinen:</strong> Automated testing çok iyi bir şeydir ve manuel testing yapılmamalıdır.</li>
<li><strong>Doğrusu:</strong> Yazılımda automated test yazılması zor olan veya gereksiz olan kısımlar olabilir. Prototip aşamasındaki veya geliştirilmesi tamamlanmamış, manuel testten geçmemiş, ihtiyaç analizi tamamlanmamış yazılımlar gibi. Ama ideal olanı automated olanıdır.</li>
<li><strong>Bilinen:</strong> Unit testing iyidir ama bunun için yeterli vaktimiz ve kaynağımız yok.</li>
<li>Bu konuya ayrıyetten girilecek...</li>
</ul>

<h1>Testing Teorisi</h1>

<p>Testing çeşitlerine gelmeden önce biraz daha teorik bilgiyle doldurayım sizi. Çünkü teori olmadan gelişen pratikten de bir nane olmuyor maalesef. Bu yüzden sizi sıksa da <a href="">Yazılım Geliştirme Modelleri</a> yazısına alalım. Çünkü bunlar üzerine bir testing sistemi oturtulabilir.</p>

<p>Yazılım modellerinde gördüğümüz çoğu modern sistem, <strong>iterasyon</strong> temelinde olmaktadır. Bunun yanında testing, günümüzde çok popülerleşen <strong>çevik süreçler</strong>de de olduğu gibi <strong>sık ve erken sürüm</strong> ihtiyacıyla beraber tüm bu yöntemlerin mümkün olmasını sağlayar. Bu yüzden de ayrı bir önemi vardır.</p>

<h2>STLC</h2>

<p>Yazılımın birçok yönüyle test edilmesi gerekmektedir. Nasıl yazılımın çeşitli safhaları ve durumları varsa (önce fonksiyon yazılır, class&#39;a eklenir, bu modül ve alt sisteme evrilir, yazılan fonksiyonlar daha önceden yazılan fonksiyonları çağırır vb.), testing için de aynı şey geçerlidir. Testing&#39;in de bu farklıları karşılayacak çeşitleri mevcuttur.</p>

<p>Aynı şekilde nasıl yazılımın, <em>Yazılım Geliştirme Yaşam Döngüsü</em> (Software Development Life Cycle - SDLC) varsa testing için de <strong>Yazılım Testi Yaşam Döngüsü - (Software Test Life Cycle) (STLC)</strong> vardır. Bunu en iyi <a href="">Yazılım Geliştirme Modelleri - V-model</a>&#39;inde görmüştük. Tabii farklı yazılım geliştirme modellerinde farklı STLC&#39;ler seçilmesi gerekebilir.</p>

<p>STLC Aşamaları:</p>

<ul>
<li>İhtiyaç analizi (Requirement Analysis): Test bakış açısıyla test edilmesi gerekenlerin ihtiyaçları çıkarılır. Bunlar test senaryoları, test ortamı analizi gibi çıktılardır. Bunlardan biri de Test ihtiyaçları matrisi <a href="https://en.wikipedia.org/wiki/Traceability_matrix">RTM</a>&#39;tir.</li>
<li>Test planlaması (Test Planning): Testing ile ilgili kaynakların, araçların vb. hazırlanmasıdır. Test plan dökümanı ve test tahmin dökümanı oluşturulur.</li>
<li>Test senaryosu geliştirmesi (Test Case Development): Test senaryolarının yazılması, test datasının yaratılması</li>
<li>Test ortamı hazırlanması (Test Environment Setup): Donanım, yazılım ve test datası kurulu ortamın hazırlanması</li>
<li>Test çalıştırılması (Test Execution)

<ul>
<li>Test planına uygun bir şekilde testlerin çalıştırılması</li>
<li>Test sonuçlarının ve başarısız test senaryolarının dökümante edilmesi</li>
<li>Başarısız sonuçların, <a href="https://en.wikipedia.org/wiki/Traceability_matrix">RTM</a>&#39;deki test senaryolarıyla ilişkilendirilmesi</li>
<li>Yazılım hatalarının takibi</li>
</ul></li>
<li>Test döngüsü sonu (Test Cycle Closure)</li>
</ul>

<h2>Testing Çeşitleri</h2>

<p>Çok çekişti testing yöntemleri vardır. Burada en temel testing yöntemlerini listeliyoruz:</p>

<ul>
<li>Manuel testing: (Henüz) otomatize edilmediği durumda uygulanması gerekir. Sürekli tekrar edilmesi sıkıcıdır ve işgücü gerektirir.</li>
<li>Otomatize testing: Yazılımsal araçlar yardımıyla gerçekleşir, test sonucu karşılaştırmalı yöntem kullanılarak rapor olarak sunulur.</li>
<li>Unit testing: Yazılımın en küçük modüllerinin test edilmesidir. Kodlama becerileri gerektirdiğinden genellikle yazılım geliştiricileri tarafından yapılır. <strong>White-box</strong> testing yöntemidir.</li>
<li>Black-box testing: Yazılımın iç işleyişi bilinmeden, sadece girdi ve çıktılarına bakarak yapılan testtir.</li>
<li>Integration testing: Unit testi yapılsa dahi bu modüllerin birbirleriyle entegrasyonunda hatalar meydana gelebilir. Çeşitli modüllerin grup halinde ve dış kaynaklarla (donanım, veritabanı vb.) beraber test edilmesidir.</li>
<li>User acceptance testing (UAT): Müşteri ya da kullanıcı tarafından yazılım ihtiyaç analizi dökümanınındaki <strong>functional</strong> ihtiyaçları karşılayıp karşılamadığına bakılır.</li>
<li>System testing: Sistemin bütünü üzerinde yapılan testing&#39;dir.

<ul>
<li>Function testing: UAT ile benzerdir. Regression testleri örnektir.</li>
<li>Non-functional testing: Yazılımın fonksiyonel olmayan yönlerinin test edilmesidir. Load testing, performance testing, security testing gibi.</li>
</ul></li>
</ul>

<h2>Test Driven Development (TDD)</h2>

<p>Çevirisini <strong>Test Yönelimli Geliştirme</strong> olarak seçmeyi tercih ettim. Yazılım geliştirirken <strong>önce</strong> testinin yazılması, daha sonra da kodun kendisinin yazılması esasına dayanmaktadır. Çok yararlıdır, ancak kullanmaya başlaması, ikna olması/edilmesi zor bir yöntemdir. Türkiye&#39;de çok fazla kullanıldığını düşünmüyorum. Ama yurt dışında kullanmayan ya çok azdır ya da kullanması gerektiğinin bilincindedir.</p>

<p><a href="/software/2015/11/14/software-development-processes#agile-model">Agile ve XP</a> yazımızda da TDD&#39;yi sıkça görürüz. Ama yine çevik prensiplerin <em>sözde</em> olarak uygulandığı ama TDD&#39;nin <strong>fazlalık</strong> olarak görüldüğü yerler de çoktur.</p>

<blockquote>
<p>Peki neden TDD? <strong>Çünkü lanet olası testleri sonradan yazması ya çok zordur ya da artık imkansız hale gelmiştir.</strong> Bu özellikle <strong>Unit Testing</strong> için geçerlidir.</p>
</blockquote>

<p><strong>Amaçlar:</strong></p>

<ul>
<li>Yazılmış kodun testinin yazılması zordur, bu yüzden önce test sonra kod</li>
<li>Zaman içindeki değişikliklerin önceden çalışan kodu bozup bozmadığının <strong>anlık</strong> kontrolü (lanetli hataların oluşmasının önlenmesi: biribirini bozan hata düzeltmeleri)</li>
<li>Değişime açık olmak</li>
</ul>

<p><strong>Hataların anlık farkedilmesi:</strong></p>

<p>Diyelim bir yazılımınızda bir hata meydana geldi. Bu müşteriden de gelebilir, siz de farketmiş olabilirsiniz. <em>TDD kullanılmayan</em> bir projede tipik olarak şunlar yaşanır.</p>

<p><img src="/assets/images/ffffuuu.png" alt=""></p>

<ul>
<li>Aslen hatayı oluşturan kodun yazılması (kimin yazdığı, zamanı belli değil)</li>
<li>Hata ile ilgili kaydın oluşturulması</li>
<li>Hatayı çözmek için bir geliştiricinin üzerine alması veya ona atanması</li>
<li>Geliştirici genelde hata ile ilgili kaydı yaratan <strong>tester</strong> ile ve/veya müşteri ile iletişime geçer, senaryoyu tam olarak anlar.</li>
<li>Geliştirici tarafından hatanın yaratılması. İki aşamadır: ilki hatanın production ortamında anlaşılması için yaratılması gerekmektedir. Bu olmuyorsa loglardan bakılarak bulunması gerekir. Her zaman yapılması zordur. İkinci aşama ise bu hatanın aynısının geliştiricinin kendi ortamında da yaratabilmesidir. İlk aşama gerçekleşse bile ortam farklarından (kod farkı, kullanıcı farklı, DB farkı...) dolayı bunu gerçekleştirmek yine zordur.</li>
<li>Geliştirici hatayı anladıktan sonra hatanın nedenini kod üzerinde tespit etmelidir. Bu işlem genelde <strong>debugging</strong> dediğimiz yöntemle yapılır. Çoğu zaman bu yöntem, kodun büyük bir kısmına hakim olmayı gerektirir. İyi düzenlenmemiş kod üzerinde saatlerce debugging yapıldığı az görünen bir şey değildir.</li>
<li>Sorunlu kod tespit edildikten sonra değiştirmek için ne gerektiği analiz edilir. Kişinin kendi yazdığı bir kod dahi olsa eski kodu anlamak zordur. <strong>Single Responsibility</strong> prensibine uyulmayan kodlarda değişiklik yapmak başka bir çok kısmı etkiler. Bu durumda yapılan değişikliğin nereleri etkileyeceği hakkında başka geliştiriciler hatta yazılım mimarları ile görüş alışverişi yapmak gerekecektir. Ender durumlarda da olsa bu bağımlılık yüzünden hatanın düzeltilmesi ertelenebilir ve hatta iptal edilebilir.</li>
<li>Düzeltme işleminden sonra kod tekrar test edilmelidir. Bizim durumumuzda bu test otomatize edilmediğinden test süreci bir haftayı bulabilir.</li>
<li>Test süreci sonrasında şanslıysak bir problem çıkmaz ve kodun tekrar canlıya atılması için örneğin 1 hafta daha gerekmektedir.</li>
<li>Şanslı değilsek ki çoğu zaman değiliz, bu hata ya hiç düzelmemiş ya da daha kötüsü başka hata(lar)a sebep olmuş olabilir. Bu durumda bu döngünün başına dönmemiz gerekiyor.</li>
</ul>

<p><img src="/assets/images/happygoat.jpg" alt=""></p>

<p>En basit bir hatanın çözümü için hatanın kaynağından itibaren günler, haftalar, aylar hatta yıllar geçmiş olabilir. Karmaşık yazılım sistemlerinde buna ratslamak çok zor değildir. Peki <em>TDD kullanılan</em> bir projede durum nasıl olurdu? İki türlü olabilirdi. İlki:</p>

<ul>
<li>Geliştirici istenen özelliği sağlayacak kod değişikliğini yapmak için test yazar</li>
<li>Test fail olur. Testi geçirecek minimum kodu yazar.</li>
<li>Başka testler fail olur. Bu durumda neden fail oldukları, yapılan son değişiklikle alakalıdır yani nedeni bellidir.</li>
<li>Ya eski kodlar tekrar düzenlenmelidir ya da yeni yazılan kod düzenlenir.</li>
<li>Düzenleme yapılır ve hiçbir testin başarız olmadığı görülür.</li>
</ul>

<p>İkinci türlü şöyle olabilirdi:</p>

<ul>
<li>Müşteriden veya sizden bir hata kaydı gelir.</li>
<li>Gerekli iletişim ve analiz yapılır (TDD kullanılmayan projeyle aynı şekilde)</li>
<li>Hata tekrar edilmesi yapılır (TDD kullanılmayan projeyle aynı şekilde)</li>
<li>Hata tespiti yine <strong>debugging</strong> yöntemiyle tespit edilir. TDD kullanılan projelerde <strong>refactoring</strong> yapıldığı için bu işlem görece daha kolaydır.</li>
<li>Geliştirici bu hatayı lokal ortamında bir test yazarak gerçekleştirir.</li>
<li>Bu testi geçirecek minimum kodu yazar.</li>
<li>Diğer unit testlerin başarısız olmadığını görür.</li>
<li><strong>QA</strong> takımı kodun son halinin <strong>regression test</strong>lerini çalıştırır.</li>
</ul>

<p>Her iki durumda da TDD&#39;nin ve <strong>test automation</strong>&#39;ın bize zaman ve emek kazandırdığını görüyoruz. Kodumuzun kalitesini kod ve hatalar açısından artırıyor. Daha da iyisi kodumuz artık değişime daha açık.</p>

<blockquote>
<p>Eğer TDD güzel bir şey ama zamanımız yok diyen birisini görürseniz bu senaryoyu anlatın. Asıl TDD kullanmamak zaman kaybıdır.</p>
</blockquote>

<h2>Unit Testing</h2>

<p>Yazılımın en küçük birimlerinin (ben bu yazıda buna <strong>fonksiyon</strong> diyeceğim) test edilmesidir. Bu kodun önceklikle <strong>test edilebilir</strong> olmasını gerektirir. Test edilebilir kodu yazmanın en doğru yolu TDD ve türevleridir.</p>

<p><strong>Test edilebilir fonksiyon:</strong></p>

<ul>
<li>Bir fonksiyon sadece bir iş yapmalıdır ya da değişmek için tek bir nedeni olmalıdır. Birden fazla iş yapıyorsa bölünmelidir (Single responsibility)</li>
<li>Nesne yönelimli dillerde olan <strong>constructor</strong> yapısının sadece <strong>field</strong> ataması için kullanılmalıdır.</li>
<li>Fonksiyona bağımlılıkların dışarıdan enjekte edilmesi. (Dependency Injection - Inversion of Control)</li>
<li>fonksiyonlara geçirilen parametreler olabildiğince basit objeler olmalıdır</li>
</ul>

<p>Şimdi sizden yazdığınız son kodlara bir bakmanızı istiyorum. Yukarıdaki prensiplere uyuyor mu? Eğer TDD ile yazılmadıysa çok zor.</p>

<p>Peki test edilebilir kodu öğrendik ama test edilebilir kodun özelliklerini farkedebildik mi?</p>

<blockquote>
<p>Test edilen fonksiyon sadece o fonksiyonla ilgili işleri yapmalıdır</p>
</blockquote>

<p>Her şey bunun için. Neden bu kadar önemli? Diyelim ki bir fonksiyonu test eden kodu yazdık ve çalıştırdık. Bu test <strong>fail</strong> oldu. bu durumda fonksiyon beklenen sonuçları üretmemiş demektir. Peki hatayı düzeltmemiz gerektiğinde nereyi düzelteceğiz. Hata fonksiyonun kendisinde mi yoksa fonksiyonun kullandığı dış kaynaklardan mı meydana geldi? Eğer fonksiyonumuz test edilebilir prensiplere uymuyorsa bunu anlamanın kolay bir yolu yoktur.</p>

<p>Fonksiyonun dış kaynaklardan bağımsız olarak test edilebilmesi için kullanılan tüm bu dış kaynakların izole edilmesi gerekir. Bu işleme <strong>mocking</strong> diyoruz. Bu iş için kullanılabilecek <code>Dummy, Fake, Stubs, Mocks</code> gibi seçenekler mevcuttur ama ben bu yazıda kolay olması açısından <code>Mock objeleri</code> seçtim.</p>

<blockquote>
<p><strong>Mock obje:</strong> Bir obje düşünün ki siz bu objeyinin fonksiyonlarını, property&#39;lerini istediğiniz çıktıları versin, istediğiniz davranışları uygulasın. Bu objeleri <strong>run-time</strong>&#39;da yaratıp, mock edilen obje yerine kullanabilirsiniz.</p>
</blockquote>

<p>Neler mock edilebilir? Fonksiyonun kullandığı tüm dış kaynaklar: HTTP request objesi, veritabanı objesi, test edilen fonksiyonun kullandığı herhangibir fonksiyon. <a href="#Demo">Demo</a>&#39;da tüm bunları daha rahat anlayacaksınız.</p>

<p><strong>İyi unit testin özellikleri:</strong></p>

<ul>
<li>(Çok) hızlı çalışması, çünkü bir kodun sonucunu ne kadar erken görebilirseniz o kadar iyidir.</li>
<li>İzole: Test edilmek istenen fonksiyonalize diğer kodlardan izole olmalıdır.</li>
<li>Tekrarlanabilir: Test her çalışmasında aynı sonucu vermelidir</li>
<li>Bağımsız: Diğer testlerin çalışmasından bağımsız olmalıdır.</li>
<li>Anlaşılabilir</li>
<li>Dökümante eder: Yazılan test aynı zamanda çok güncel bir dökümantasyondur (BDD)</li>
</ul>

<p><strong>Yazma Yöntemleri (TDD):</strong></p>

<ol>
<li> Red: İstenen test yazılır. Bu test çalıştırılır ve başarısız olur.</li>
<li> Green: Testi geçirecek minimum kod yazılır. Dış kaynaklar, bağımlılıklar mock ile soyutlanabilir.</li>
<li> Refactor: Düzenleme işlemidir. Artık teste dayanan bir kodumuz olduğundan testin fail olmamasına dikkat ederek içimiz rahat kodumuzu düzenleyebiliriz.</li>
<li> Tekrar</li>
</ol>

<p>Bu yöntemler takip edildiği takdirde, iyi bir unit test yazmış oluruz. Peki bu yöntem (TDD) aynı zamanda bize geliştirme esnasında nasıl yardımcı olur ona bakalım.</p>

<p><strong>Sernaryo:</strong> Bir ERP yazılımı yapıyorsunuz ve sizden istenen şey: siparişi görüp iptal etmek veya bir notla beraber ilgili departmana iletmek olsun.</p>

<p><em>TDD kullanılmayan</em> örneğimizde geliştirme yöntemi genelde şu şekilde olacaktır.</p>

<ol>
<li>İstenen işlemleri yapacak kod yazılır.</li>
<li>Daha sonra yazılım derlenir ve local ortamda çalıştırılır. Bu iş çeşitli gereksinimler gerektirebilir: DB, network bağlantısı gibi.</li>
<li>Müşteri rolünde bir kullanıcıyla sisteme giriş yapılır.</li>
<li>Sipariş oluşturmak için gerekli ekranlarda veriler girilir</li>
<li>Sistemden çıkılıp siparişleri görebilen bir kullanıcıyla tekrar girilir.</li>
<li>Sistemden sipariş görülür ve kodlanan özelliğin doğru çalışıp çalışmadığına bakılır.</li>
</ol>

<p>Eğer şanslıysanız ki çoğu zaman değilsiniz, bu işlemi 2-3 kere tekrar ederek istenen kodu yazabilirsiniz ama biz biliyoruz ki yazılan kodu test edebilmek için bu doğrudan alakası olmayan işleri çok kereler tekrarlamanız gerekecek. Üstelik bu işin müşteriden, QA&#39;den dönme durumunda yine aynı adımları izlemeniz gerekecek.</p>

<p><em>TDD kullanılan</em> örneğimizde belki işimiz çok kolay olmayacak ama bize şu basit faydaları sağlayacaktır:</p>

<ul>
<li>Test yazmak basit ve etkili bir analiz ve tasarım sağlar</li>
<li>Geliştirme esnasında kodun ne yapıp yapamadığının anlık sonucunu görmek konsantrasyonun dağılmadan geliştirebilmeyi sağlar</li>
<li>Değiştirilen kodun başka yerleri bozup bozmadığının farkında olabilmek daha radikal (ve doğru) değişiklikleri mümkün kılar</li>
<li>Yazılan testler geliştiriciler için en güncel dökümantasyonu sağlar</li>
<li>Testlerin izole yazılması sayesinde yazılımın diğer kısımlarından bağımsız geliştirilmesi sağlanabilir.</li>
<li>Kodun bambaşka bir yerindeki bug artık sizin geliştirmenizi engellemez</li>
</ul>

<h2>Integration Testing</h2>

<p>Karmaşık bir yazılım birçok alt yazılımların birleşimiyle meydana gelir.  geliştirilen bu modüller birbirleriyle belirli arayüzlerle etkileşerek çalışırlar. Görülmüştür ki bu modüllerin entegrasyonu yazılım geliştirmesindeki en zorlu süreçlerden biridir.</p>

<p>Bunu çözebilmek için çevik prensiplerden de yararlanarak integration testing ortaya çıkarılmıştır. Farklı stratejiler mevcuttur:</p>

<ul>
<li>Big Bang Yöntemi: Geliştirilen tüm modüller tek bir kerede birleştirilir ve test edilir. Tüm modüllerin bitmesini gerektirir ve çıkan hataların ana kaynağını tespit etmek zordur.</li>
<li>Incremental (Birikmeli) Yöntem: <em>Buttom Up</em> (alttan üste), <em>Top Down</em> (üstten alta) ve ikisinin birleşimi <em>Sandwich</em> yöntemleri kullanılabilir. Seçilen yönteme göre <strong>stub</strong> ve <strong>driver</strong> yazılması gerekebilir. <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></li>
</ul>

<p><img src="/assets/images/topbottom.png" alt=""></p>

<h2>System Testing</h2>

<p>Ürünün canlıya çıkmadan önce yapılan yazılım sisteminin bütününün test edilmesidir. Yazılımın aynı zamanda donanım ve diğer dış kaynaklarla beraber denenmesidir. 50&#39;den fazla çeşidi bununmaktadır. Kullanılabilirlik (usablity), regression <sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup>, functional, performans en çok kullanılan system testing çeşitlerindendir.</p>

<p>Çoğu zaman Functional Requirement Specification (FRS) <sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup>, System Requirement Specification (SRS) <sup id="fnref4"><a href="#fn4" rel="footnote">4</a></sup> gibi üst seviye dökümantasyonlardan yararlanılır.</p>

<h1>Code Coverage (Test Coverage)</h1>

<p>Yazılan testlerin, yazılımı gerçekte ne kadarını kapsadığının hesaplandığı yöntemdir. Teorik olarak code coverage %100 olan yazılımlar hatasızdır denebilir ancak pratikte birçok yönden çok fazla sayıda test yazılmasını gerektireceği için çok zordur. Ancak oran ne kadar yüksekse hata oluşma olasılığı düşer.</p>

<p><strong>TDD</strong> kullanımı code coverage&#39;ın yüksek tutulması için bir yöntem olarak düşünülebilir çünkü TDD ile testi olmayan kod yazılmaması amaçlanır.</p>

<p>Çok kullanılan code coverage ölçüm yöntemleri:</p>

<ul>
<li>Statement Coverage: Kaynak kodunun satır bazında ne kadarının çalıştığına bakar</li>
<li>Decision Coverage: <code>if</code>, <code>while</code> gibi karar elemanlarında <code>boolean</code> değerinin tümüne bakar. bir kere <code>true</code> bir kere de <code>false</code> seçilebilmesi yeterlidir.</li>
<li>Condition Coverage: Yine decision coverage gibi ama bu sefer karar statement&#39;larınındaki tüm değişkenler test edilmeli.</li>
</ul>

<h1>Continuous integration</h1>

<h1>Continuous Delivery</h1>

<h1>Demo</h1>

<h1>Kaynaklar</h1>

<ul>
<li><a href="http://www.turkishtestingboard.org/files/ISTQB-Yazilim-Testi-Terimler-Sozlugu.pdf">http://www.turkishtestingboard.org/files/ISTQB-Yazilim-Testi-Terimler-Sozlugu.pdf</a></li>
<li><a href="http://www.guru99.com/software-testing-life-cycle.html">http://www.guru99.com/software-testing-life-cycle.html</a></li>
<li><a href="http://istqbexamcertification.com/what-is-integration-testing">http://istqbexamcertification.com/what-is-integration-testing</a></li>
<li><a href="http://googletesting.blogspot.co.uk/2015/04/just-say-no-to-more-end-to-end-tests.html">http://googletesting.blogspot.co.uk/2015/04/just-say-no-to-more-end-to-end-tests.html</a></li>
<li><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=203994">http://www.artima.com/weblogs/viewpost.jsp?thread=203994</a></li>
<li><a href="http://www.developertesting.com/archives/month200705/20070504-000425.html">http://www.developertesting.com/archives/month200705/20070504-000425.html</a></li>
<li><a href="http://www.bullseye.com/coverage.html">http://www.bullseye.com/coverage.html</a></li>
</ul>

<p><br /></p>

<div class="seriesNote">
  Bu makale <strong>2</strong> bölümlük <strong>Teori Önemlidir!</strong> serisinin <strong>2.</strong> bölümüdür.</p>
    <ul>
    
    
    
    
    
    
    
    
    
    
    
    
    
        

    
    
        <li class="">Part 1 -
        
            <a href="/software/2015/11/14/software-development-processes">
        
    Yazılım Geliştirme Modelleri
    
      </a>
    
        </li>
    
    
    
    
    
    
    
        

    
    
        <li class="selected">Part 2 -
        
    Software Testing
    
        </li>
    
    
    
    
    </ul>
</div>

<p><br /></p>

<p><strong>Dipnotlar:</strong></p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p><a href="http://testingbasicinterviewquestions.blogspot.com.tr/2012/01/why-we-use-stubs-and-drivers.html">http://testingbasicinterviewquestions.blogspot.com.tr/2012/01/why-we-use-stubs-and-drivers.html</a>&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p><a href="https://en.wikipedia.org/wiki/Regression_testing">https://en.wikipedia.org/wiki/Regression_testing</a>&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p><a href="https://en.wikipedia.org/wiki/Functional_requirement">https://en.wikipedia.org/wiki/Functional_requirement</a>&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

<li id="fn4">
<p><a href="https://en.wikipedia.org/wiki/Requirements_analysis">https://en.wikipedia.org/wiki/Requirements_analysis</a>&nbsp;<a href="#fnref4" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

					<div class="meta">
						<p class="date-publish">
							Published:
							<date class="date-pub" title="2015-11-15T00:00:00+02:00" datetime="2015-11-15T00:00:00+02:00" pubdate>
							<span class="month"><abbr>November</abbr></span>
							<span class="day">15</span>
							<span class="year">2015</span>
							</date>
						</p>
						<ul class="list-category list-linear">
							<li class="list-head">category: </li>
							
							


  
    
    	<li><a href="/categories.html#software-ref">
    		software <span>2</span>
    	</a></li>
    
  



						</ul>
						<ul class="list-tag list-linear">
							<li class="list-head">tags: </li>
							
							


  
    
    	<li><a href="/tags.html#testing-ref">testing <span>1</span></a></li>
    
    	<li><a href="/tags.html#tdd-ref">tdd <span>1</span></a></li>
    
    	<li><a href="/tags.html#unit test-ref">unit test <span>1</span></a></li>
    
    	<li><a href="/tags.html#integration test-ref">integration test <span>1</span></a></li>
    
    	<li><a href="/tags.html#system test-ref">system test <span>1</span></a></li>
    
  



						</ul>
					</div><!-- meta -->
				</div><!-- entry-content -->
				<div class="misc-content">
					<div class="social">
						<ul class="list-linear">
							<li><div class="twitter-tweet"><a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-via="mustapha_alaziz" data-lang="en">Tweet</a></div></li>
							<li><div class="twitter-follow"><a href="https://twitter.com/mustapha_alaziz" class="twitter-follow-button" data-show-count="false" data-lang="en"></a></div></li>
						</ul>
					</div>
					<div class="comment">
					


  <div id="disqus_thread"></div>
<script type="text/javascript">
    

    
    var disqus_shortname = 'dhalsimblog'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




					</div>
				</div><!-- misc-content -->
			</div><!-- bd -->
			<footer class="unit-foot">
				<div class="unit-inner unit-foot-inner">
					<nav class="pagination">
						<ul>
							
							<li class="prev"><a class="internal" rel="prev"  href="/node.js/2015/11/15/multi-room-chat-application" title="View Çok Odalı Node.js Chat Uygulaması">&laquo; Çok Odalı Node.js Chat Uygulaması</a></li>
							
							
							<li class="pipe"> | </li>
							
							
							<li class="next"><a class="internal" rel="next"  href="/javascript/2015/12/18/temel-javascript" title="View Temel Javascript">Temel Javascript &raquo;</a></li>
							
						</ul>
					</nav>
				</div>
			</footer>

		</div><!-- content -->
	</div><!-- unit-inner -->
</article>


				</div>
			</div><!-- unit-inner -->
		</div><!-- unit-body -->
	</div><!-- body -->
	<footer class="the-footer">
		<div class="unit-foot">
			<div class="unit-inner unit-foot-inner">
				<div class="misc vcard">
					<h4>Hakkımda</h4>
					<img src="/assets/me_rounded.png" style="width: 150px" />
					<ul>
						<li class="contact"><span class="author fn n">Barış Aydek</span></li>
						<li class="contact"><address><span class="fn email"><a href="mailto:baris.aydek@gmail.com">baris.aydek@gmail.com</a></span></address></li>
						<li class="github"><a href="http://github.com/dhalsim/" rel="me">github.com/dhalsim</a></li>
						<li class="twitter"><a href="http://twitter.com/mustapha_alaziz/" rel="me">twitter.com/mustapha_alaziz</a></li>
						<li class="linkedin"><a href="https://www.linkedin.com/in/baris-aydek-39352325" rel="me">linkedin.com</a></li>
					</ul>
				</div><!-- misc -->
			</div><!-- unit-foot-inner -->
		</div><!-- unit-foot -->
	</footer>
</div><!-- page -->
<script>
	(function(d, s) {
		var js, fjs = d.getElementsByTagName(s)[0], load = function(url, id) {
		if (d.getElementById(id)) {return;}
		js = d.createElement(s); js.src = url; js.id = id;
		fjs.parentNode.insertBefore(js, fjs);
		};
	load('//platform.twitter.com/widgets.js', 'tweetjs');
	// load('https://apis.google.com/js/plusone.js', 'gplus1js'); // Checkout http://j.mp/ApDgMr for usage html for this is <div class="g-plusone" data-size="medium"></div>
	// load('//connect.facebook.net/en_US/all.js#xfbml=1', 'fbjssdk'); // Checkout http://j.mp/wZw2xR for using open graph protorol html for this is <div class="fb-like" data-href="/software/2015/11/15/software-testing" data-send="false" data-layout="button_count" data-width="450" data-show-faces="false" data-font="verdana"></div>
	}(document, 'script'));
</script>
<script>
/*! A fix for the iOS orientationchange zoom bug.Script by @scottjehl, rebound by @wilto. MIT License.*/
(function(j){var i=j.document;if(!i.querySelectorAll){return}var l=i.querySelectorAll("meta[name=viewport]")[0],a=l&&l.getAttribute("content"),h=a+", maximum-scale=1.0",d=a+", maximum-scale=10.0",g=true,c=j.orientation,k=0;if(!l){return}function f(){l.setAttribute("content",d);g=true}function b(){l.setAttribute("content",h);g=false}function e(m){c=Math.abs(j.orientation);k=Math.abs(m.gamma);if(k>8&&c===0){if(g){b()}}else{if(!g){f()}}}j.addEventListener("orientationchange",f,false);j.addEventListener("deviceorientation",e,false)})(this);
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js" charset="utf-8"></script>
<script type="text/javascript">
$(document).ready(function(){
	// browser window scroll (in pixels) after which the "back to top" link is shown
	var offset = 300,
	//browser window scroll (in pixels) after which the "back to top" link opacity is reduced
	offset_opacity = 1200,
	//duration of the top scrolling animation (in ms)
	scroll_top_duration = 700,
	//grab the "back to top" link
	$back_to_top = $('.cd-top');

	//hide or show the "back to top" link
	$(window).scroll(function(){
		( $(this).scrollTop() > offset ) ? $back_to_top.addClass('cd-is-visible') : $back_to_top.removeClass('cd-is-visible cd-fade-out');
		if( $(this).scrollTop() > offset_opacity ) {
			$back_to_top.addClass('cd-fade-out');
		}
	});

	//smooth scroll to top
	$back_to_top.on('click', function(event){
		event.preventDefault();
		$('body,html').animate({
			scrollTop: 0 ,
		 	}, scroll_top_duration
		);
	});
});
</script>


<script src="http://cdnjs.cloudflare.com/ajax/libs/modernizr/2.0.6/modernizr.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/2.0.0/anchor.min.js" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.pack.js" charset="utf-8"></script>
<script type="text/javascript">
	$(document).ready(function () {
		anchors.add('.content h1');
		anchors.add('.content h2');
		anchors.add('.content h3');
		anchors.add('.content h4');
		anchors.add('.content h5');

		var level = 1;
		var $parentUl = $currentUl = $('<ul/>');
		var count = 0;
		var listTypes = ['decimal', 'lower-alpha', 'circle']
		$('.anchorjs-link').each(function () {
			count++;
			if(count === 1)
			{
				return true;
			}

			var $this = $(this);
			var $parent = $this.parent();
			var tagName = $parent.prop("tagName");
			var thisLevel = tagName.charAt(1);
			var text = $parent.text();

			if(thisLevel > level) {
				var $newUl = $('<ul/>');
				$currentUl.append($newUl);
				$currentUl = $newUl;
			} else if(thisLevel < level) {
				var diff = level - thisLevel;
				$currentUl = $currentUl.parents().eq(diff-1);
			}

			var $a = $('<a/>');
			$a.text(text);
			$a.attr('href', $this.attr('href'));

			level = thisLevel;
			$currentUl.css('list-style', listTypes[level - 1]);
			$currentUl.append($('<li/>').append($a));
		});

		$('.content header').append(
			$('.toc').html(
				$('<h4/>', {text: 'İçindekiler: '})
			).append($parentUl)
		);

		$('.content img')
			.attr('title', 'Resmi büyütmek için üstüne tıklayınız.')
			.click(function (e) {
				var img = $('<img/>', {src: this.src});
				return $.fancybox(img);
			});
	});
</script>


  





  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-70097547-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>




</body>
</html>

